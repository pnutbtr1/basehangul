#!/usr/bin/tcc -run
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <errno.h>

#define DEBUG 0

int code2euc(unsigned short num);
int euc2code(unsigned short num);
int geteuc(FILE *f);
void puteuc(short num);

//TODO: UTF-8 지원
typedef char utf8char[3];

static int wrap = 40, wrapcount = 0;

const char usage[] = "Usage: basehangul [-d] [-w\x1b[3mwrap\x1b[0m] \x1b[3mfilename\x1b[0m\n";

int main(int argc, char *argv[])
{
    int i, c, ind = 0, numBytes = 5, opt;
    unsigned char buf[5];
    short eucbuf[4];
    char decode = 0;
    FILE *f;
    opterr = 0;

    while ((opt = getopt(argc, argv, "w:d")) != -1) {
        switch (opt) {
            case 'w':
                wrap = atoi(optarg);
                break;
            case 'd':
                decode = 1;
                break;
            case '?':
                fputs(usage, stderr);
                break;
        }
    }
    if (optind == argc - 1) {
        if (!strcmp(argv[optind], "-"))
            f = stdin;
        else
            f = fopen(argv[optind], "r");

        if (f == NULL) {
            fprintf(stderr, "open failed: %s\n", strerror(errno));
            exit(-1);
        }
    } else {
        fputs(usage, stderr);
        exit(-1);
    }

    if (!decode) {
        while (EOF != (c = fgetc(f))) {
            buf[ind++] = (char) c;
            ind %= 5;
            if (!ind) {
                eucbuf[0] = code2euc(0x3FF & (buf[0]<<2 | buf[1]>>6));
                eucbuf[1] = code2euc(0x3FF & (buf[1]<<4 | buf[2]>>4));
                eucbuf[2] = code2euc(0x3FF & (buf[2]<<6 | buf[3]>>2));
                eucbuf[3] = code2euc(0x3FF & (buf[3]<<8 | buf[4]));
                for (i = 0; i < 4; i++)
                    puteuc(eucbuf[i]);
            }
        }
        if (ind) {
            if (DEBUG) {
                fprintf(stderr, "\nind: %d\n", ind);
                for(i = 0; i < ind; i++)
                    fprintf(stderr, "%02X\n", buf[i]);
            }
            for(i = ind; i < 5; i++)
                buf[i] = 0;
            for(i = ind; i < 4; i++)
                eucbuf[i] = 0xc8e5; // 패딩 '흐'
            switch (ind) {
                case 4:
                    eucbuf[3] = code2euc((buf[3] & 3) + 1024);
//                    eucbuf[3] = code2euc(((0x3 & buf[3]) << 8) + 1024);
                case 3:
                    eucbuf[2] = code2euc(0x3FF & (buf[2]<<6 | buf[3]>>2));
                case 2:
                    eucbuf[1] = code2euc(0x3FF & (buf[1]<<4 | buf[2]>>4));
                case 1:
                    eucbuf[0] = code2euc(0x3FF & (buf[0]<<2 | buf[1]>>6));
            }
            for (i = 0; i < 4; i++)
                puteuc(eucbuf[i]);
        }
        fputc('\n', stdout);
    } else {
        while (-1 != (c = geteuc(f))) {
            if (c == '\n' || c == '\r')
                continue;
            eucbuf[ind++] = euc2code(c);
            if (DEBUG)
                fprintf(stderr, "c: %d code: %d\n", c, euc2code(c));
            ind %= 4;
            if (!ind) {
                buf[0] = (char) (eucbuf[0] >> 2);
                buf[1] = (char) (eucbuf[0] << 6 | (0x3FF & eucbuf[1]) >> 4);
                buf[2] = (char) (eucbuf[1] << 4 | (0x3FF & eucbuf[2]) >> 6);
                buf[3] = (char) (eucbuf[2] << 2 | (0x3FF & eucbuf[3]) >> 8);
                buf[4] = (char) (eucbuf[3]);
                if (DEBUG)
                    fprintf(stderr, "buf: %02X %02X %02X %02X %02X\n", buf[0], buf[1], buf[2], buf[3], buf[4]);
                numBytes = 5;
                for (i = 3; i > 0; i--)
                    if (eucbuf[i] != 2324) {
                        if (i != 3)
                            numBytes = i+1;
                        break;
                    }
                if (eucbuf[3] == 2324)
                    numBytes = 3;
                if (eucbuf[2] == 2324)
                    numBytes = 2;
                if (eucbuf[1] == 2324)
                    numBytes = 1;
                if (eucbuf[3] >= 1024 && eucbuf[3] != 2324) {
                    numBytes = 4;
                    buf[3] = (char) (eucbuf[2] << 2 | (0x3 & eucbuf[3]));
                }
                if (DEBUG)
                    fprintf(stderr, "numBytes: %d\n", numBytes);
                for (i = 0; i < numBytes; i++)
                    putc(buf[i], stdout);
            }
        }
    }

    fclose(f);

    return 0;
}


int code2euc(unsigned short num)
{
    int a,b,c;
    a = num / 94 + 0xb0;
    b = (num % 94 + 1) / 16;
    c = (num % 94 + 1) % 16;

    return a << 8 | (b+10) << 4 | c;
}


int euc2code(unsigned short num)
{
    unsigned int a,b,c;
    a = ((num & 0xFF00) >> 8) - 0xb0;
    b = ((num & 0xF0) >> 4) - 10;
    c = num & 0xF;
    
    return 94 * a + (16 * b + c - 1);
}


int geteuc(FILE *f)
{
    int a, b;
    if ((a = fgetc(f)) == EOF)
        return -1;
    if (!(0x80 & a))
        return a;
    if ((b = fgetc(f)) == EOF)
        return -1;

    if (DEBUG)
        fprintf(stderr, "[INFO] geteuc: a: %02X, b: %02X\n", a, b);
    return (unsigned char)a << 8 | (unsigned char)b;
}


void puteuc(short num)
{
    fputc(num >> 8, stdout);
    fputc(num & 255, stdout);
    if (wrap && ++wrapcount == wrap) {
        fputc('\n', stdout);
        wrapcount = 0;
    }
}

// vim: ft=c ts=4 sw=4 et nu rnu
